# defmodule Ethereumex.IpcClient do
#   use Ethereumex.Client.Macro
#   import Ethereumex.Config
#   @moduledoc false
#
#   @spec single_request(map()) :: {:ok, any() | [any()]} | error
#   def single_request(payload) do
#     payload
#     |> encode_payload
#     |> post_request
#   end
#
#   @spec encode_payload(map()) :: binary()
#   defp encode_payload(payload) do
#     payload |> Poison.encode!()
#   end
# #   @spec post_request(binary()) :: {:ok | :error, any()}
# # #  @spec post_request(integer(), map()) :: {:ok | :error, any()}
# #   defp post_request(payload) do
# #     opts = Ethereumex.Config.ipc_options()
# #
# #   #  with {:ok, Sock} <- :gen_udp.open(port, opts),
# #     # client(PortNo,Message) ->
# #     #     {ok,Sock} = gen_tcp:connect("localhost",PortNo,[{active,false},{packet,2}]),
# #     #     gen_tcp:send(Sock,Message),
# #     #     A = gen_tcp:recv(Sock,0),
# #     #     gen_tcp:close(Sock),
# #     #     A.
# #
# #
# #   #
# #   #   with {:ok, response} <-
# #   #
#   # end
# end
# # start(Num,LPort) ->
# #     case gen_tcp:listen(LPort,[{active, false},{packet,2}]) of
# #         {ok, ListenSock} ->
# #             start_servers(Num,ListenSock),
# #             {ok, Port} = inet:port(ListenSock),
# #             Port;
# #         {error,Reason} ->
# #             {error,Reason}
# #     end.
# #
# # start_servers(0,_) ->
# #     ok;
# # start_servers(Num,LS) ->
# #     spawn(?MODULE,server,[LS]),
# #     start_servers(Num-1,LS).
# #
# # server(LS) ->
# #     case gen_tcp:accept(LS) of
# #         {ok,S} ->
# #             loop(S),
# #             server(LS);
# #         Other ->
# #             io:format("accept returned ~w - goodbye!~n",[Other]),
# #             ok
# #     end.
# #
# # loop(S) ->
# #     inet:setopts(S,[{active,once}]),
# #     receive
# #         {tcp,S,Data} ->
# #             Answer = process(Data), % Not implemented in this example
# #             gen_tcp:send(S,Answer),
# #             loop(S);
# #         {tcp_closed,S} ->
# #             io:format("Socket ~w closed [~w]~n",[S,self()]),
# #             ok
# #     end.
# # Example of a simple client:
# #
# # client(PortNo,Message) ->
# #     {ok,Sock} = gen_tcp:connect("localhost",PortNo,[{active,false},
# #                                                     {packet,2}]),
# #     gen_tcp:send(Sock,Message),
# #     A = gen_tcp:recv(Sock,0),
# #     gen_tcp:close(Sock),
# #     A.
